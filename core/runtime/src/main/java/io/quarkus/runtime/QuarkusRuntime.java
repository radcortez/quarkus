package io.quarkus.runtime;

import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.eclipse.microprofile.config.spi.ConfigSource;

import io.quarkus.runtime.QuarkusRuntime.Info.SimpleInfo;
import io.smallrye.config.common.AbstractConfigSource;

/**
 * Provides a low-level API for registering and accessing runtime values generated by Quarkus or Quarkus
 * extensions. Typically, such values describe a fully configured application, known only at application startup,
 * such as the HTTP port.
 * <p>
 * These values should not be exposed by the Config mechanism directly, as that would require mutating the Config
 * system, which should be immutable, and cause hard-to-debug issues. Instead, {@code QuarkusRuntime} should be
 * preferred for exposing such values.
 */
public class QuarkusRuntime {
    private static final Map<String, Info<?>> values = new ConcurrentHashMap<>();

    /**
     * Registers a value with a specified key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @throws IllegalArgumentException if the specified key already has an associated value
     */
    public static <T> void register(final RuntimeKey<T> key, final T value) {
        registerInfo(key, SimpleInfo.of(value));
    }

    /**
     * Registers a {@link Info} with a specified key.
     *
     * @param key key with which the specified value is to be associated
     * @param info value to be associated with the specified key
     * @throws IllegalArgumentException if the specified key already has an associated value
     * @see io.quarkus.runtime.QuarkusRuntime.Info
     */
    public static <T> void registerInfo(final RuntimeKey<T> key, final Info<T> info) {
        Info<?> mapValue = values.putIfAbsent(key.key(), info);
        if (mapValue != null) {
            throw new IllegalArgumentException("Key already registered " + key.key() + " with value " + mapValue.get());
        }
    }

    /**
     * Returns {@code true} if {@link QuarkusRuntime} contains a mapping for the specified key.
     *
     * @param key key whose presence in {@link QuarkusRuntime} is to be tested
     * @return {@code true} if {@link QuarkusRuntime} contains a mapping for the specified key
     */
    public static <T> boolean containsKey(final RuntimeKey<T> key) {
        return values.containsKey(key.key());
    }

    /**
     * Returns the value to which the specified key is mapped.
     *
     * @param key the key whose associated value is to be returned
     * @return the value to which the specified key is mapped
     * @throws java.lang.IllegalArgumentException if the specified key has no associated value
     */
    @SuppressWarnings("unchecked")
    public static <T> T get(final RuntimeKey<T> key) {
        Info<T> info = (Info<T>) values.get(key.key());
        if (info == null) {
            throw new IllegalArgumentException("Key " + key.key() + " not found");
        }
        return info.get();
    }

    /**
     * Returns the value to which the specified key is mapped.
     *
     * @param key the key whose associated value is to be returned
     * @param defaultValue the default mapping of the key
     * @return the value to which the specified key is mapped, or {@code defaultValue} if the key has no value
     */
    @SuppressWarnings("unchecked")
    public static <T> T getOrDefault(final RuntimeKey<T> key, final T defaultValue) {
        Info<T> info = (Info<T>) values.get(key.key());
        return info == null ? defaultValue : info.get();
    }

    /**
     * Returns the resulting {@link Info} value to which the specified key is mapped.
     *
     * @param key the key whose associated value is to be returned
     * @param properties a Map that carries information to construct a new instance of {@code T} from {@link Info}
     * @return the value to which the specified key is mapped
     * @throws java.lang.IllegalArgumentException if the specified key has no associated value
     */
    @SuppressWarnings("unchecked")
    public static <T> T getInfo(final RuntimeKey<T> key, final Map<String, Object> properties) {
        Info<T> info = (Info<T>) values.get(key.key());
        if (info == null) {
            throw new IllegalArgumentException("Key " + key.key() + " not found");
        }
        return info.get(properties);
    }

    /**
     * Allows to defer and retrieve instances of an object that represent information only available at
     * runtime with {@link QuarkusRuntime}.
     */
    public interface Info<T> {
        /**
         * Construct a new instance of {@code T}.
         *
         * @return an instance of {@code T}.
         */
        T get();

        /**
         * Construct a new instance of {@code T}.
         *
         * @param properties a Map that carries information to construct a new instance of {@code T}.
         * @return an instance of {@code T}.
         */
        T get(Map<String, Object> properties);

        class SimpleInfo<T> implements Info<T> {
            private final T value;

            SimpleInfo(T value) {
                this.value = value;
            }

            @Override
            public T get() {
                return value;
            }

            @Override
            public T get(Map<String, Object> properties) {
                return value;
            }

            static <T> SimpleInfo<T> of(final T value) {
                return new SimpleInfo<>(value);
            }
        }
    }

    /**
     * A typed key.
     */
    public static final class RuntimeKey<T> {
        private final String key;

        RuntimeKey(String key) {
            this.key = key;
        }

        public String key() {
            return key;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof RuntimeKey<?> that))
                return false;
            return Objects.equals(key, that.key);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(key);
        }

        public static <T> RuntimeKey<T> key(final String key) {
            return new RuntimeKey<>(key);
        }

        public static <T> RuntimeKey<T> key(final Class<T> type) {
            return new RuntimeKey<>(type.getName());
        }

        public static RuntimeKey<Integer> intKey(final String key) {
            return new RuntimeKey<>(key);
        }

        // TODO - Add static constructors as needed
    }

    /**
     * A {@link ConfigSource} to bridge between the Config System and {@link QuarkusRuntime}.
     * <p>
     * While {@link QuarkusRuntime} shouldn't be exposed in the Config System, this is intended to
     * work as a temporary compatibility layer, since until the introduction of {@link QuarkusRuntime},
     * the norm was to use {@link io.smallrye.config.SmallRyeConfig} and System Properties to relay this kind of
     * information.
     * <p>
     * This should be kept until we decide on an alternate solution in the discussion
     * <a href="https://github.com/quarkusio/quarkus/discussions/46915">#46915</a>.
     *
     * @return a {@link ConfigSource} to bridge to {@link QuarkusRuntime}.
     */
    public static ConfigSource getConfigSource() {
        // ordinal just a bit lower than Build Time Runtime fixed source
        return new AbstractConfigSource("Quarkus Runtime Values", Integer.MAX_VALUE - 10) {
            @Override
            public Set<String> getPropertyNames() {
                return Set.of();
            }

            @Override
            public String getValue(final String propertyName) {
                Info<?> value = values.get(propertyName);
                // TODO - We may require to convert this to the expected config string
                return value != null ? value.get().toString() : null;
            }
        };
    }
}
